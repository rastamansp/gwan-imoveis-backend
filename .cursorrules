# ğŸš€ Cursor Rules - Plataforma de Eventos e Venda de Ingressos

## ğŸ“‹ VisÃ£o Geral do Projeto

Este Ã© um projeto NestJS com TypeScript que implementa uma plataforma completa de eventos e venda de ingressos. O projeto segue os princÃ­pios de Clean Architecture, SOLID e Use Cases, oferecendo funcionalidades de gestÃ£o de eventos, usuÃ¡rios, ingressos, pagamentos e analytics administrativos.

## ğŸš« **REGRAS CRÃTICAS - NUNCA VIOLAR**

### âŒ **NUNCA desabilitar funcionalidades essenciais:**
- âŒ **NUNCA** comentar TypeORM ou banco de dados
- âŒ **NUNCA** remover validaÃ§Ãµes de entrada
- âŒ **NUNCA** desabilitar logging ou tratamento de erros
- âŒ **NUNCA** remover interfaces ou abstraÃ§Ãµes
- âŒ **NUNCA** usar `any` type ou `console.log`
- âŒ **NUNCA** fazer operaÃ§Ãµes sÃ­ncronas bloqueantes

### âœ… **SEMPRE corrigir problemas de configuraÃ§Ã£o:**
- âœ… **SEMPRE** verificar variÃ¡veis de ambiente
- âœ… **SEMPRE** configurar conexÃµes de banco corretamente
- âœ… **SEMPRE** implementar fallbacks e retry logic
- âœ… **SEMPRE** usar logging estruturado para debug
- âœ… **SEMPRE** seguir princÃ­pios de resiliÃªncia

## ğŸ—ï¸ Arquitetura e PadrÃµes

### Clean Architecture
- **Entities**: Regras de negÃ³cio centrais
- **Use Cases**: Casos de uso da aplicaÃ§Ã£o
- **Interface Adapters**: Controllers, Repositories, External Services
- **Frameworks & Drivers**: NestJS, Database, RabbitMQ, Playwright

### SOLID Principles
- **S**: Single Responsibility Principle
- **O**: Open/Closed Principle
- **L**: Liskov Substitution Principle
- **I**: Interface Segregation Principle
- **D**: Dependency Inversion Principle

### Design Patterns
- **Repository Pattern**: Para acesso a dados
- **Factory Pattern**: Para criaÃ§Ã£o de objetos complexos
- **Strategy Pattern**: Para diferentes mÃ©todos de pagamento
- **Observer Pattern**: Para notificaÃ§Ãµes de eventos
- **Command Pattern**: Para operaÃ§Ãµes de negÃ³cio
- **Facade Pattern**: Para simplificar operaÃ§Ãµes complexas

## ğŸ“ Estrutura de Pastas

```
src/
â”œâ”€â”€ main.ts                           # Ponto de entrada
â”œâ”€â”€ app.module.ts                     # MÃ³dulo principal
â”œâ”€â”€ shared/                           # CÃ³digo compartilhado
â”‚   â”œâ”€â”€ domain/                       # Entidades e regras de negÃ³cio
â”‚   â”œâ”€â”€ infrastructure/               # ImplementaÃ§Ãµes externas
â”‚   â”œâ”€â”€ application/                  # Casos de uso
â”‚   â””â”€â”€ presentation/                 # Controllers e DTOs
â”œâ”€â”€ modules/                          # MÃ³dulos da aplicaÃ§Ã£o
â”‚   â”œâ”€â”€ auth/                         # AutenticaÃ§Ã£o e autorizaÃ§Ã£o
â”‚   â”œâ”€â”€ users/                        # GestÃ£o de usuÃ¡rios
â”‚   â”œâ”€â”€ events/                       # GestÃ£o de eventos
â”‚   â”œâ”€â”€ tickets/                      # GestÃ£o de ingressos
â”‚   â”œâ”€â”€ payments/                     # Sistema de pagamentos
â”‚   â””â”€â”€ admin/                        # Painel administrativo
â”œâ”€â”€ config/                           # ConfiguraÃ§Ãµes
â””â”€â”€ common/                           # UtilitÃ¡rios e decorators
```

## ğŸ”§ PadrÃµes de CÃ³digo

### Nomenclatura
- **Classes**: PascalCase (ex: `EventsService`, `TicketsService`)
- **Interfaces**: PascalCase com prefixo I (ex: `IEventRepository`)
- **MÃ©todos**: camelCase (ex: `createEvent`, `validateTicket`)
- **VariÃ¡veis**: camelCase (ex: `eventData`, `ticketInfo`)
- **Constantes**: UPPER_SNAKE_CASE (ex: `MAX_TICKETS_PER_USER`)
- **Arquivos**: kebab-case (ex: `events.service.ts`, `tickets.controller.ts`)

### Estrutura de Classes
```typescript
// Sempre usar decorators do NestJS
@Injectable()
export class EventsService {
  constructor(
    private readonly eventRepository: IEventRepository,
    private readonly logger: ILogger,
  ) {}

  // MÃ©todos pÃºblicos primeiro
  public async createEvent(eventData: CreateEventDto): Promise<Event> {
    // ImplementaÃ§Ã£o
  }

  // MÃ©todos privados depois
  private async validateEventData(data: CreateEventDto): Promise<void> {
    // ValidaÃ§Ã£o
  }
}
```

### DTOs e ValidaÃ§Ã£o
```typescript
// Sempre usar class-validator
export class CreateEventDto {
  @IsString()
  @IsNotEmpty()
  @MaxLength(255)
  title: string;

  @IsString()
  @IsNotEmpty()
  @MaxLength(1000)
  description: string;

  @IsDateString()
  date: string;

  @IsOptional()
  @IsNumber()
  @Min(1)
  @Max(100000)
  maxCapacity?: number;
}
```

### Interfaces e AbstraÃ§Ãµes
```typescript
// Sempre definir interfaces para dependÃªncias
export interface IEventRepository {
  save(event: Event): Promise<Event>;
  findById(id: string): Promise<Event | null>;
  findByOrganizer(organizerId: string): Promise<Event[]>;
}

// Implementar com classes concretas
@Injectable()
export class EventRepository implements IEventRepository {
  // ImplementaÃ§Ã£o
}
```

## ğŸ¯ PadrÃµes de Use Cases

### Estrutura de Use Case
```typescript
@Injectable()
export class CreateEventUseCase {
  constructor(
    private readonly eventRepository: IEventRepository,
    private readonly userRepository: IUserRepository,
    private readonly logger: ILogger,
  ) {}

  public async execute(command: CreateEventCommand): Promise<CreateEventResult> {
    try {
      // 1. ValidaÃ§Ã£o
      await this.validateCommand(command);
      
      // 2. ExecuÃ§Ã£o da lÃ³gica de negÃ³cio
      const result = await this.processEventCreation(command);
      
      // 3. PersistÃªncia
      await this.saveEvent(result);
      
      // 4. NotificaÃ§Ã£o
      await this.notifyEventCreated(result);
      
      return result;
    } catch (error) {
      this.logger.error('Erro ao criar evento', { command, error });
      throw new EventCreationError(error.message);
    }
  }

  private async validateCommand(command: CreateEventCommand): Promise<void> {
    // ValidaÃ§Ã£o especÃ­fica do use case
  }

  private async processEventCreation(command: CreateEventCommand): Promise<Event> {
    // LÃ³gica de negÃ³cio principal
  }
}
```

## ğŸ”Œ PadrÃµes do NestJS

### MÃ³dulos
```typescript
@Module({
  imports: [
    // MÃ³dulos externos primeiro
    TypeOrmModule.forFeature([Event, Ticket, Payment]),
    
    // MÃ³dulos internos depois
    AuthModule,
    UsersModule,
  ],
  controllers: [EventsController],
  providers: [
    // Use Cases
    CreateEventUseCase,
    PurchaseTicketUseCase,
    
    // Services
    EventsService,
    TicketsService,
    
    // Repositories
    {
      provide: IEventRepository,
      useClass: EventRepository,
    },
  ],
  exports: [EventsService],
})
export class EventsModule {}
```

### Controllers
```typescript
@Controller('events')
export class EventsController {
  constructor(
    private readonly createEventUseCase: CreateEventUseCase,
    private readonly purchaseTicketUseCase: PurchaseTicketUseCase,
  ) {}

  @Post()
  @HttpCode(201)
  @UseGuards(JwtAuthGuard)
  public async createEvent(
    @Body() createEventDto: CreateEventDto,
    @Request() req: any,
  ): Promise<CreateEventResponseDto> {
    const command = new CreateEventCommand(createEventDto, req.user.id);
    const result = await this.createEventUseCase.execute(command);
    
    return CreateEventResponseDto.fromResult(result);
  }

  @Post(':id/tickets')
  @HttpCode(201)
  @UseGuards(JwtAuthGuard)
  public async purchaseTicket(
    @Param('id') eventId: string,
    @Body() purchaseTicketDto: PurchaseTicketDto,
    @Request() req: any,
  ): Promise<PurchaseTicketResponseDto> {
    const command = new PurchaseTicketCommand(eventId, purchaseTicketDto, req.user.id);
    const result = await this.purchaseTicketUseCase.execute(command);
    
    return PurchaseTicketResponseDto.fromResult(result);
  }
}
```

### Arquivos .http para Testes
Cada API criada deve ter um arquivo `.http` correspondente para facilitar os testes via REST Client.

**Estrutura dos arquivos .http:**
```
src/
â”œâ”€â”€ modules/
â”‚   â”œâ”€â”€ events/
â”‚   â”‚   â”œâ”€â”€ events.controller.ts
â”‚   â”‚   â””â”€â”€ events.http                  # Arquivo de testes da API
â”‚   â”œâ”€â”€ tickets/
â”‚   â”‚   â”œâ”€â”€ tickets.controller.ts
â”‚   â”‚   â””â”€â”€ tickets.http                 # Arquivo de testes da API
â”‚   â””â”€â”€ payments/
â”‚       â”œâ”€â”€ payments.controller.ts
â”‚       â””â”€â”€ payments.http                # Arquivo de testes da API
```

**Exemplo de arquivo .http:**
```http
### Criar novo evento
POST http://localhost:3001/api/events
Content-Type: application/json
Authorization: Bearer {{token}}

{
  "title": "Festival de MÃºsica",
  "description": "O maior festival da cidade",
  "date": "2024-06-15T20:00:00Z",
  "location": "Parque da Cidade",
  "maxCapacity": 5000
}

### Listar eventos
GET http://localhost:3001/api/events

### Obter evento por ID
GET http://localhost:3001/api/events/{{eventId}}

### Comprar ingresso
POST http://localhost:3001/api/events/{{eventId}}/tickets
Content-Type: application/json
Authorization: Bearer {{token}}

{
  "categoryId": "1",
  "quantity": 2
}
```

## ğŸ—„ï¸ PadrÃµes de Banco de Dados

### Entities
```typescript
@Entity('events')
export class Event {
  @PrimaryGeneratedColumn('uuid')
  id: string;

  @Column({ type: 'varchar', length: 255 })
  title: string;

  @Column({ type: 'text' })
  description: string;

  @Column({ type: 'timestamp' })
  date: Date;

  @Column({ type: 'varchar', length: 255 })
  location: string;

  @Column({ type: 'varchar', length: 50, default: 'ACTIVE' })
  status: EventStatus;

  @Column({ type: 'int', default: 0 })
  maxCapacity: number;

  @Column({ type: 'int', default: 0 })
  soldTickets: number;

  @CreateDateColumn()
  createdAt: Date;

  @UpdateDateColumn()
  updatedAt: Date;

  // MÃ©todos de domÃ­nio
  public markAsSoldOut(): void {
    this.status = EventStatus.SOLD_OUT;
  }

  public addSoldTickets(quantity: number): void {
    this.soldTickets += quantity;
    if (this.soldTickets >= this.maxCapacity) {
      this.markAsSoldOut();
    }
  }
}
```

## ğŸš€ PadrÃµes de ConfiguraÃ§Ã£o

### Environment Variables
```typescript
// Sempre usar ConfigService
@Injectable()
export class AppConfig {
  constructor(private configService: ConfigService) {}

  get databaseUrl(): string {
    return this.configService.get<string>('DATABASE_URL');
  }

  get jwtSecret(): string {
    return this.configService.get<string>('JWT_SECRET');
  }

  get port(): number {
    return this.configService.get<number>('PORT', 3001);
  }
}
```

### Dependency Injection
```typescript
// Sempre usar interfaces para dependÃªncias
@Injectable()
export class EventsService {
  constructor(
    @Inject(IEventRepository)
    private readonly eventRepository: IEventRepository,
    
    @Inject(ITicketRepository)
    private readonly ticketRepository: ITicketRepository,
  ) {}
}
```

## ğŸ“ PadrÃµes de Logging

### Estrutura de Logs
```typescript
// Sempre usar logs estruturados
@Injectable()
export class EventsService {
  constructor(private readonly logger: ILogger) {}

  public async createEvent(eventData: CreateEventDto): Promise<Event> {
    this.logger.info('Iniciando criaÃ§Ã£o de evento', {
      title: eventData.title,
      date: eventData.date,
      organizerId: eventData.organizerId,
      timestamp: new Date().toISOString(),
    });

    try {
      // ExecuÃ§Ã£o
      const event = await this.processEventCreation(eventData);
      this.logger.info('Evento criado com sucesso', { eventId: event.id });
      return event;
    } catch (error) {
      this.logger.error('Erro ao criar evento', {
        title: eventData.title,
        error: error.message,
        stack: error.stack,
      });
      throw error;
    }
  }
}
```

## ğŸ§ª PadrÃµes de Testes (Futuro)

### Estrutura de Testes
```typescript
// Testes unitÃ¡rios para use cases
describe('CreateEventUseCase', () => {
  let useCase: CreateEventUseCase;
  let mockRepository: jest.Mocked<IEventRepository>;

  beforeEach(() => {
    mockRepository = createMockRepository();
    useCase = new CreateEventUseCase(mockRepository);
  });

  it('should create event successfully', async () => {
    // Arrange
    const command = new CreateEventCommand({ title: 'Festival de MÃºsica' });
    
    // Act
    const result = await useCase.execute(command);
    
    // Assert
    expect(result).toBeDefined();
    expect(mockRepository.save).toHaveBeenCalled();
  });
});
```

## ğŸ”’ PadrÃµes de SeguranÃ§a

### ValidaÃ§Ã£o de Entrada
- Sempre validar DTOs com class-validator
- Usar transformadores para sanitizaÃ§Ã£o
- Implementar rate limiting
- Validar tipos de dados

### Tratamento de Erros
```typescript
// Sempre usar custom exceptions
export class EventCreationError extends Error {
  constructor(message: string, public readonly code: string) {
    super(message);
    this.name = 'EventCreationError';
  }
}

// E filtros de exceÃ§Ã£o
@Catch(EventCreationError)
export class EventCreationFilter implements ExceptionFilter {
  catch(exception: EventCreationError, host: ArgumentsHost) {
    const ctx = host.switchToHttp();
    const response = ctx.getResponse<Response>();
    
    response.status(400).json({
      statusCode: 400,
      message: exception.message,
      code: exception.code,
      timestamp: new Date().toISOString(),
    });
  }
}
```

## ğŸ“Š PadrÃµes de Performance

### OtimizaÃ§Ãµes
- Usar lazy loading quando apropriado
- Implementar cache para dados frequentemente acessados
- Usar paginaÃ§Ã£o para grandes conjuntos de dados
- Implementar timeouts para operaÃ§Ãµes externas

### Monitoramento
```typescript
// Sempre medir performance de operaÃ§Ãµes crÃ­ticas
@Injectable()
export class EventsService {
  public async createEvent(eventData: CreateEventDto): Promise<Event> {
    const startTime = Date.now();
    
    try {
      const result = await this.performEventCreation(eventData);
      
      const duration = Date.now() - startTime;
      this.logger.info('Evento criado', {
        title: eventData.title,
        duration,
        eventId: result.id,
      });
      
      return result;
    } catch (error) {
      const duration = Date.now() - startTime;
      this.logger.error('CriaÃ§Ã£o de evento falhou', {
        title: eventData.title,
        duration,
        error: error.message,
      });
      throw error;
    }
  }
}
```

## ğŸš« O que NÃƒO fazer

- âŒ NÃ£o usar `any` type
- âŒ NÃ£o fazer console.log (usar logger estruturado)
- âŒ NÃ£o deixar mÃ©todos pÃºblicos sem necessidade
- âŒ NÃ£o misturar lÃ³gica de negÃ³cio com controllers
- âŒ NÃ£o usar singletons desnecessÃ¡rios
- âŒ NÃ£o fazer operaÃ§Ãµes sÃ­ncronas bloqueantes
- âŒ NÃ£o esquecer de tratar erros
- âŒ NÃ£o usar variÃ¡veis globais
- âŒ **NUNCA desabilitar funcionalidades essenciais (banco, validaÃ§Ãµes, etc.)**

## âœ… O que SEMPRE fazer

- âœ… Usar TypeScript strict mode
- âœ… Implementar interfaces para dependÃªncias
- âœ… Usar decorators do NestJS apropriadamente
- âœ… Validar entrada de dados
- âœ… Tratar erros adequadamente
- âœ… Usar logs estruturados
- âœ… Seguir princÃ­pios SOLID
- âœ… Implementar Clean Architecture
- âœ… Usar injeÃ§Ã£o de dependÃªncia
- âœ… Documentar APIs com Swagger
- âœ… Criar arquivo .http para cada API (testes via REST Client)
- âœ… **SEMPRE corrigir problemas de configuraÃ§Ã£o ao invÃ©s de desabilitar funcionalidades**

## ğŸ“š DocumentaÃ§Ã£o AutomÃ¡tica

### Sistema de DocumentaÃ§Ã£o AutomÃ¡tica
O projeto inclui um sistema completo de documentaÃ§Ã£o automÃ¡tica que gera, valida e mantÃ©m a documentaÃ§Ã£o atualizada.

### Scripts de DocumentaÃ§Ã£o
```bash
# Gerar toda a documentaÃ§Ã£o
npm run docs:generate

# Validar documentaÃ§Ã£o existente
npm run docs:validate

# Servir documentaÃ§Ã£o localmente
npm run docs:serve

# Monitorar mudanÃ§as e regenerar automaticamente
npm run docs:watch

# Limpar arquivos gerados
npm run docs:clean

# Mostrar ajuda
npm run docs:help
```

### Estrutura de DocumentaÃ§Ã£o
```
docs/
â”œâ”€â”€ README.md                    # Ãndice principal
â”œâ”€â”€ architecture/               # DocumentaÃ§Ã£o de arquitetura
â”œâ”€â”€ development/                # Guias de desenvolvimento
â”œâ”€â”€ api/                        # DocumentaÃ§Ã£o de APIs
â”œâ”€â”€ mcp/                        # DocumentaÃ§Ã£o MCP
â”œâ”€â”€ deployment/                 # Guias de deploy
â”œâ”€â”€ diagrams/                   # Diagramas Mermaid
â””â”€â”€ generated/                  # Arquivos gerados automaticamente
    â”œâ”€â”€ api-*.md               # DocumentaÃ§Ã£o de APIs por mÃ³dulo
    â”œâ”€â”€ *-generated.md        # DocumentaÃ§Ã£o geral
    â”œâ”€â”€ *.md                   # Diagramas Mermaid
    â””â”€â”€ cache/                 # Cache de geraÃ§Ã£o
```

### Geradores DisponÃ­veis
- **Gerador de APIs** - Baseado na especificaÃ§Ã£o OpenAPI
- **Gerador de Diagramas** - Diagramas Mermaid automÃ¡ticos
- **Gerador Geral** - AnÃ¡lise de controllers e serviÃ§os
- **Validador** - ValidaÃ§Ã£o de estrutura e conteÃºdo

### ConfiguraÃ§Ã£o
- **Arquivo:** `docs.config.js` - ConfiguraÃ§Ãµes centralizadas
- **VariÃ¡veis:** `API_BASE_URL`, `DOCS_PORT`, `LOG_LEVEL`
- **Monitoramento:** Watch automÃ¡tico de arquivos
- **Cache:** Sistema de cache para performance

### PadrÃµes de DocumentaÃ§Ã£o
- âœ… **SEMPRE** gerar documentaÃ§Ã£o automÃ¡tica apÃ³s mudanÃ§as
- âœ… **SEMPRE** validar documentaÃ§Ã£o antes do commit
- âœ… **SEMPRE** usar diagramas Mermaid para arquitetura
- âœ… **SEMPRE** manter documentaÃ§Ã£o atualizada
- âœ… **SEMPRE** seguir padrÃµes de Markdown
- âŒ **NUNCA** commitar documentaÃ§Ã£o desatualizada
- âŒ **NUNCA** ignorar validaÃ§Ãµes de documentaÃ§Ã£o

## ğŸš€ Deploy e ProduÃ§Ã£o

### Fluxo de Deploy AutomÃ¡tico
1. **Desenvolvimento** - CÃ³digo e documentaÃ§Ã£o
2. **ValidaÃ§Ã£o** - Testes e validaÃ§Ã£o de documentaÃ§Ã£o
3. **Build** - CompilaÃ§Ã£o e preparaÃ§Ã£o
4. **Deploy** - Deploy automÃ¡tico para produÃ§Ã£o
5. **Monitoramento** - Acompanhamento em produÃ§Ã£o

### Scripts de Deploy
```bash
# Preparar para deploy
npm run build
npm run docs:generate
npm run docs:validate

# Deploy para produÃ§Ã£o
npm run deploy:prod

# Rollback se necessÃ¡rio
npm run deploy:rollback
```

### ConfiguraÃ§Ãµes de ProduÃ§Ã£o
- **Environment Variables** - ConfiguraÃ§Ãµes especÃ­ficas de produÃ§Ã£o
- **Database Migrations** - ExecuÃ§Ã£o automÃ¡tica de migraÃ§Ãµes
- **Health Checks** - VerificaÃ§Ã£o de saÃºde da aplicaÃ§Ã£o
- **Monitoring** - Logs e mÃ©tricas em produÃ§Ã£o
- **Backup** - EstratÃ©gias de backup automÃ¡tico

### CI/CD Pipeline
- **GitHub Actions** - Pipeline automÃ¡tico de deploy
- **ValidaÃ§Ã£o** - Testes e linting automÃ¡ticos
- **DocumentaÃ§Ã£o** - GeraÃ§Ã£o e validaÃ§Ã£o automÃ¡tica
- **Deploy** - Deploy automÃ¡tico apÃ³s validaÃ§Ã£o
- **NotificaÃ§Ãµes** - Alertas de sucesso/falha

## ğŸ”„ Fluxo de Desenvolvimento Completo

1. **Definir Use Case** - O que a funcionalidade deve fazer
2. **Criar Interface** - Como a funcionalidade se comunica
3. **Implementar** - CÃ³digo seguindo os padrÃµes
4. **Validar** - Verificar se segue as regras
5. **Testar** - Funcionalidade funciona corretamente
6. **Documentar** - API e cÃ³digo bem documentados
7. **Gerar DocumentaÃ§Ã£o** - DocumentaÃ§Ã£o automÃ¡tica atualizada
8. **Validar DocumentaÃ§Ã£o** - Verificar consistÃªncia e qualidade
9. **Commit** - Commit com documentaÃ§Ã£o atualizada
10. **Deploy** - Deploy automÃ¡tico para produÃ§Ã£o

### Comandos Essenciais para Deploy
```bash
# Fluxo completo de desenvolvimento
npm run start:dev                    # Desenvolvimento
npm run docs:watch                   # Monitorar documentaÃ§Ã£o
npm run test                         # Testes
npm run lint                         # Linting
npm run docs:generate               # Gerar documentaÃ§Ã£o
npm run docs:validate               # Validar documentaÃ§Ã£o
npm run build                        # Build para produÃ§Ã£o
git add .                           # Adicionar mudanÃ§as
git commit -m "feat: nova funcionalidade"  # Commit
git push origin main                 # Push para repositÃ³rio
# Deploy automÃ¡tico via CI/CD
```

---

**Lembre-se**: Este arquivo define os padrÃµes do projeto. Sempre consulte antes de implementar novas funcionalidades para garantir consistÃªncia e qualidade do cÃ³digo. **NUNCA desabilite funcionalidades essenciais - sempre corrija os problemas de configuraÃ§Ã£o!**

**Importante**: Sempre gerar e validar a documentaÃ§Ã£o antes de fazer commit e deploy para produÃ§Ã£o!

